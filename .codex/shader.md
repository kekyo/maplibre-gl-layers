## 経緯

描画パフォーマンスの改善作業を行っている。

現在の実装は、CPUで様々な計算を行って、それをシェーダーに流し込んでいる。
CPU計算コストが膨らんできたので、これをシェーダーに移行したい。

先に試行したビルボード表示モードのシェーダー移行は成功した。

サーフェイス表示モードのスプライト画像描画のCPU計算をシェーダーコードに移行しようとしたが失敗。
表示まではこぎ着けたが、以下の問題が発生し、解消できなかった:

1. 地図の上下左右スクロールや、ズームインアウトを行うと、その各ステップでテクスチャが乱れる。テクスチャが乱れる理由はよくわからないが、全く判別できないわけではなく、矢印がひしゃげたり欠けたりしていた。
2. 矢印が移動するとき、各補間フレームでガタガタと移動する。つまり、本来の座標と少しずれた位置に描画される。ずれる量も一定ではないので、ガタガタと移動する。移動方向自体は正しいように見える。まるで計算精度が足りなくて切り捨てかなにかが発生しているかのようだった。これは試行途中で一部の座標計算をCPU側に戻すことで改善された。

## 問題の分析結果

現状整理と次の打ち手案を以下にまとめます。

1. 予想通り精度不足が支配要因
   surfaceClipDiagnostics の出力からも分かる通り、GPU が求めたクリップ座標と CPU の結果に最大で Δclip ≈ 50、ΔNDC ≈ 0.03 程度の差が出ています。ズームインで歪みが増す挙動とも一致しており、精度不足が原因であることは確定的です。
2. 移動時のガタつきが解消された理由
   ふらつきの解消は「座標を再補間する経路が CPU と揃った」ことによるものですが、根本は「毎フレームの高精度な位置を参照できている」点にあります（現在も CPU が算出した clipPosition を頂点バッファに書き込む fallback が残っているため）。
   とはいえシェーダー経路で座標差分を計算する場合、今回のテクスチャ歪み同様に float32 の丸めが蓄積すれば再発し得ます。つまり「ふらつきは解消されたが、根本的には同じ精度問題の延長上」と見ておくべきです。
3. hi/lo 分割が効かない理由
   指摘の通り、WebGL1 の頂点シェーダーは float32 でしか計算できません。hi/lo に分割して渡しても、シェーダー側で再結合するときに float32 同士を足し合わせるだけなので、64bit 精度は回復しません。
   hi/lo 方式が効果を持つのは「CPU で hi/lo を足し戻して double として扱う」ケースであり、GPU 上では float → float の加算に過ぎません。差分がゼロに近付かなかったのはこのためです。
4. 精度問題を除いた GPU への移行余地
   高ズームでも正確さが求められる「地理座標 → メルカトル → クリップ」変換は、現状 WebGL1 (単精度) では CPU に任せざるを得ません。ここは MapLibre 本体も CPU 側で行っている部分で、GPU に寄せるメリットよりもリスクが大きい領域です。

一方で、以下の計算なら GPU 移行の効果が期待できます：

* アンカー補正/回転/オフセット → 平面直交メートル系のまま扱う部分
  こちらは既にサーフェス用 CPU 経路でもメートル単位で扱っており、ローカル座標系なので float32 でも精度が充分。
* シェーダー内でのテクスチャ座標計算やベクター操作
  Sprite の向き・アニメーションなど、地理座標に依らない処理は GPU でも安全。
* 視覚効果（フェード、カラー変換等）
  こちらは元々 GPU で実行しており、今回のような地理変換とは切り離せます。

したがって、GPU への移行は「ローカル平面内の計算」や「テクスチャ操作」に留め、最終的な地理→クリップ変換だけを CPU で済ませる形が妥当と考えます。

## 今後の方針

* 当初の、サーフェイスモードの頂点計算をシェーダーに移行するのは断念する。
* "アンカー補正/回転/オフセット", "シェーダー内でのテクスチャ座標計算やベクター操作" の移行計画を考察する。　
